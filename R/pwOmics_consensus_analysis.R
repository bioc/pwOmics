#' Static analysis.
#' 
#' Identify for each corresponding timepoint of the two datasets the consensus
#' network. Protein intersection of the omics data and TF intersection are 
#' linked via SteinerTree algorithm applied on STRING protein-protein
#' interaction database. 
#' The Steiner tree algorithm refers to the shortest path heuristic algorithm
#' of [1,2].
#' Target genes of this consensus network are identified via the chosen
#' TF-target gene database(s). Please note that the consensus graphs can be
#' different as in the Steiner Tree algorithm the start terminal node is 
#' picked arbitrarily and there are always several shortest path distances. 
#'  
#' @references 1. Path heuristic and Original path heuristic, Section 4.1.3 of 
#' the book "The Steiner tree Problem", Peter L. Hammer
#' @references 2. "An approximate solution for the Steiner problem in graphs", 
#' H Takahashi, A Matsuyama
#'  
#'  
#' @param data_omics OmicsData object.
#' @param run_times integer specifying number of times to run SP Steiner tree 
#' algorithm to find minimal graph, default is 3.
#' @return list of igraph objects; length corresponds to number of overlapping 
#' time points from upstream and downstream analysis.
#' @keywords manip
#' @export
#' @examples
#' #please run with whole database files (prepared according to vignette)
#' data(OmicsExampleData)
#' data_omics = readOmics(tp_prots = c(0.25, 1, 4, 8, 13, 18, 24), 
#' tp_genes = c(1, 4, 8, 13, 18, 24), OmicsExampleData,
#' PWdatabase = c("biocarta", "kegg", "nci", "reactome"), 
#' TFtargetdatabase = c("chea", "pazar"))
#' \dontrun{
#' data_omics = readTFdata(data_omics)
#' data_omics_plus = readPWdata(data_omics,  
#' loadgenelists = FALSE)
#' data_omics = identifyPWs(data_omics_plus)
#' data_omics = identifyTFs(data_omics)
#' data_omics = enrichPWs(data_omics)
#' data_omics = identifyRsofTFs(data_omics, only_enriched = FALSE, 
#' noTFs_inPW = 1, order_neighbors = 10)
#' data_omics = identifyPWTFTGs(data_omics, only_enriched = FALSE)
#' statConsNet = staticConsensusNet(data_omics)
#' }
staticConsensusNet <- function(data_omics, run_times = 3) {
    
    if(class(data_omics) != "OmicsData")
    {stop("Parameter 'data_omics' is not an OmicsData object.")}
    
    string_db = STRINGdb$new(version = "9_05", species = 9606,
                             score_threshold = 0, input_directory = "") 
    PPI_graph = getSTRING_graph(string_db) 
    
    same_tps = data_omics[[1]][[1]][[1]][[1]][which(data_omics[[1]][[1]][[1]][[1]] 
                                                    %in% data_omics[[1]][[1]][[1]][[2]])]
    if(length(same_tps) == 0)
    {stop("No matching time points were found in the two 
          corresponding data sets.")}
    
    ST_proteins = vector()
    consensus_graph = list()
    for(tps in 1: length(same_tps))
    {
        STRINGIDs = getConsensusSTRINGIDs(data_omics, tps, string_db)
        message("Consensus graph for time point ", same_tps[tps], 
                " was generated.\n")   
        
        ST_net = SteinerTree_cons(STRINGIDs$STRING_id, 
                                  PPI_graph, run_times) 
        ST_net = getAliasfromSTRINGIDs(data_omics, ST_net, 
                                       STRINGIDs, tps, string_db)
        
        V(ST_net)$label.cex = 1
        plot(ST_net, main = paste("Steiner tree of consensus graph\n time ", 
                                  same_tps[tps], sep = ""))
        legend(x = 0, y = -1.2 , legend = c("consensus proteins",
                "steiner node proteins", "consensus TFs"), 
                fill = c("red", "yellow", "lightblue"), cex = 0.7)
        message("Steiner tree of consensus graph for time point ", same_tps[tps],
            " was build.\n")

        ST_TFTG = getbipartitegraphInfo(data_omics, tps)
        ST_net_targets = genfullConsensusGraph(ST_net, ST_TFTG)
        V(ST_net_targets)$label.cex = 0.6
        plot.igraph(ST_net_targets, main = paste("Consensus graph\n time ", 
                    same_tps[tps], sep = ""), vertex.size = 18)
        legend(x = 0, y = -1.2 , legend = c("consensus proteins", 
        "steiner node proteins", "consensus TFs", "consensus target genes"), 
               fill = c("red", "yellow", "lightblue", "green"), cex = 0.7)
        
        ST_net_targets = addFeedbackLoops(ST_net_targets)
        consensus_graph[[tps]] = ST_net_targets
    }
    names(consensus_graph) = as.character(same_tps)
    return(consensus_graph)
}

#' Generate STRING PPI graph.
#' 
#' Generates connected graph with undirected edges from STRING PPI-database.
#' 
#' @param string_db STRING_db object generated by getConsensusSTRINGIDs 
#' function.
#' @return igraph object connected graph from STRING PPI database.
#' 
#' @keywords manip
getSTRING_graph <- function(string_db){
    string_homo_new = string_db$load()
    conn_intgraph = decompose.graph(string_homo_new)[[1]]
    graph_STRING = conn_intgraph
    
    return(graph_STRING)
} 


#' Add feedback loops from target genes to proteins/TFs if present.
#' 
#' @param ST_net_targets full consensus graph.
#' @return igraph object with feedback loops added.
#' 
#' @keywords manip
addFeedbackLoops <- function(ST_net_targets){
    
    prot_nodes = V(ST_net_targets)$name[which(V(ST_net_targets)$color == "red" | 
                                                  V(ST_net_targets)$color == "yellow" |
                                                  V(ST_net_targets)$color == "lightblue")]
    gene_nodes = 
        V(ST_net_targets)$name[which(V(ST_net_targets)$color == "green")]
    for(h in 1: length(prot_nodes))
    { feedback_ind = vector()
      if(prot_nodes[h] %in% gene_nodes)
      {
          feedback_ind = which(V(ST_net_targets)$name == prot_nodes[h])
          ST_net_targets[feedback_ind[1],feedback_ind[2] ] = 1
      }
    }    
    return(ST_net_targets)
}

#' Combine SteinerNet with bipartite graph to get full consensus network.
#' 
#' @param ST_net steiner tree graph generated by SteinerTree_cons function.
#' @param ST_TFTG steiner tree graph extended with consensus target genes and 
#' the edges between TFs and target genes.
#' @return igraph object of network comprising steiner tree graph and 
#' TF - target gene interactions.
#' 
#' @keywords manip
genfullConsensusGraph <- function(ST_net, ST_TFTG){
    
    ST_net_targets = ST_net
    for(s in 1: length(ST_TFTG))
    {
        if(s>1)
        {targets_in_graph = V(ST_net_targets)$name[which(V(ST_net_targets)$color == "green")]
         targets_to_add = unique(ST_TFTG[[s]])[which(!unique(ST_TFTG[[s]]) %in% targets_in_graph)]
        }else{
            targets_to_add = unique(ST_TFTG[[s]])    
        }
        temp = ST_net_targets
        ST_net_targets = ST_net_targets + targets_to_add
        len_targets = length(targets_to_add)
        if(len_targets >=1)
        {V(ST_net_targets)$color[(length(V(temp))+1):(length(V(temp)) + len_targets)] = "green"}
        
        ind = which(V(ST_net_targets)$name == names(ST_TFTG[s]) &
                        V(ST_net_targets)$color == "lightblue")
        ind_green = which(V(ST_net_targets)$color == "green" &
                              V(ST_net_targets)$name %in% unique(ST_TFTG[[s]]) )
        if(length(ind)>0)
        {ST_net_targets = add.edges(ST_net_targets, rbind(ind_green, ind))}
        
    }
    return(ST_net_targets)
}



#' Get TF-target gene information for the consensus graph.
#' 
#' @param data_omics OmicsData object.
#' @param tps integer specifying current timepoint under consideration.
#' @return list of transcription factor target gene interactions.
#' 
#' @keywords manip
getbipartitegraphInfo <- function(data_omics, tps){
    ST_TFs = 
        gettpIntersection(data_omics)$Intersection$TF_Intersection[tps][[1]]
    ST_targets = 
        gettpIntersection(data_omics)$Intersection$Genes_Intersection[tps][[1]]
    ST_TFTG = list()
    for(k in 1: length(ST_TFs))
    {ST_TFTG[[k]] = as.character(data_omics[[3]][[2]][which(as.character
                                                            (data_omics[[3]][[2]][,1]) == ST_TFs[k]),2])
     ST_TFTG[[k]] = ST_TFTG[[k]][which(ST_TFTG[[k]] %in% ST_targets)]
    }
    names(ST_TFTG) = ST_TFs
    return(ST_TFTG)  
}

#' Map alias names to STRING IDs of consensus graph.
#' 
#' @param data_omics OmicsData object.
#' @param ST_net steiner tree graph generated by SteinerTree_cons function.
#' @param consSTRINGIDs first element of list generated by getConsensusSTRINGIDs 
#' function; a data.frame including the proteins to be considered as terminal 
#' nodes in Steiner tree with colnames ST_proteins and the corresponding STRING 
#' IDs in column 'STRING_id'.
#' @param tps integer specifying current timepoint under consideration.
#' @param string_db second element of list generated by getConsensusSTRINGIDs 
#' function; species table (for human) of STRING database.
#' @return igraph object with alias name annotation.
#' 
#' @keywords manip
getAliasfromSTRINGIDs <- function(data_omics, ST_net, consSTRINGIDs, tps,
                                  string_db){
    
    ST_netnames = V(ST_net)$name
    ind_name = which(ST_netnames %in% consSTRINGIDs$STRING_id)
    ST_netnames[ind_name] = consSTRINGIDs$ST_proteins[na.omit(match(ST_netnames, 
                                                                    consSTRINGIDs$STRING_id))]
    temp_STR = as.data.frame(ST_netnames[-ind_name])
    colnames(temp_STR) = "STRING_id"
    ST_netnames[-ind_name] = 
        string_db$add_proteins_description(temp_STR)$preferred_name
    V(ST_net)$name = ST_netnames
    TF_proteins = 
        gettpIntersection(data_omics)$Intersection$TF_Intersection[tps][[1]]
    V(ST_net)$color[which(V(ST_net)$name %in% TF_proteins)] = "lightblue"
    
    return(ST_net)
}

#' Get consensus graph in STRING IDs.
#' 
#' @param data_omics OmicsData object.
#' @param tps integer specifying current timepoint under consideration.
#' @param string_db STRING_db object.
#' @return igraph object consensus graph with STRING IDs (only including 
#' proteins and transcription factors).
#' 
#' @keywords manip
getConsensusSTRINGIDs <- function(data_omics, tps, string_db){
    
    ST_proteins = 
        gettpIntersection(data_omics)$Intersection$Protein_Intersection[tps][[1]]
    ST_proteins = unique(c(ST_proteins,
                           gettpIntersection(data_omics)$Intersection$TF_Intersection[tps][[1]]))
    ST_proteins_STRINGid = string_db$map(as.data.frame(ST_proteins),
                                         "ST_proteins", takeFirst = TRUE)
    doubID = which(duplicated(ST_proteins_STRINGid$ST_proteins))
    if(length(doubID)>0)
    {consSTRINGIDs = ST_proteins_STRINGid[-doubID,]  
    }else{
        consSTRINGIDs = ST_proteins_STRINGid}
    return(consSTRINGIDs)
}

#' Steiner tree algorithm.
#' 
#' Use this function to get the Steiner tree based on the STRING protein-protein 
#' interaction database.
#'  
#' @param terminal_nodes character vector of final nodes used for generation
#' of Steiner tree.
#' @param PPI_graph igraph object; graph should be connected and have
#' undirected edges.
#' @param run_times integer specifying number of times to run SP Steiner tree
#' algorithm to find minimal graph.
#' @return igraph object including Steiner tree.
#' 
#' @keywords manip
SteinerTree_cons <- function(terminal_nodes, PPI_graph, run_times) {
    
    requireNamespace(igraph, quiet = TRUE)
    altunion = igraph::union
    unloadNamespace(igraph) 
    
    color = NULL
    terminal_nodes = na.omit(terminal_nodes)
    V(PPI_graph)$color = "yellow"
    V(PPI_graph)[terminal_nodes]$color = "red"
    terminals = V(PPI_graph)[color == "red"]
    steinertmin = vector()
    steinertrees = list()
    for(runs in 1: run_times)
    {edges = c()
     prob = sample(1:length(terminals), 1, replace = FALSE)
     subtree = terminals$name[[prob]]
     nsubtree = setdiff(terminals$name, subtree)
     tparam = 1
     while(tparam <= length(terminals))
     {   
         paths = get.all.shortest.paths(PPI_graph,subtree, nsubtree)
         if(length(paths$res)>1)
         {
             paths_length = sapply(paths$res, length)
             sp = paths$res[which(paths_length == min(paths_length))][[1]]
             subtree = altunion(subtree, V(PPI_graph)$name[sp])
             nsubtree = setdiff(nsubtree, V(PPI_graph)$name[sp])
         }else{
             subtree = subtree
             nsubtree = nsubtree
         }
         tparam = tparam+1
     }
     steinert = minimum.spanning.tree(induced.subgraph(PPI_graph, subtree))
     for(i in length(which(V(steinert)$color == "yellow"))+1)
     { degr = degree(steinert, v = V(steinert), mode = c("all"))
       todel = names(which(degr == 1))
       todel = todel[which(!todel %in% terminals$name)]
       if(length(todel) > 0)
       {steinert = delete.vertices(steinert, todel)}
     } 
     steinertrees[[runs]] = steinert
     steinertmin[runs]  = length(V(steinert)$name)
    }
    return(steinertrees[[which(steinertmin == min(steinertmin))[1]]])  
} 


#' Dynamic analysis.
#' 
#' Generates continous data for dynamic analysis of protein, TF and gene data
#' via smoothing splines. 50 time points are generated this way.  
#' The following nodes are considered: 
#' Nodes which are part of the static consensus graphs from corresponding time 
#' points of the two different measurement types. In case a node is not
#' significantly changed at a certain point in time its FC is assumed to remain
#' constant at this time point.
#' Calculation of the dynamic consensus net parameters are based on the ebdbNet 
#' R package [1]. The number of time points generated via smoothing splines (50) 
#' is based on their results for median AUCs of ROC curves.
#' The number of forward time units a node is assumed to influence other nodes
#' can be specified via the laghankel parameter. The cutoff determining the
#' percent of total variance explained by the singular values generated by
#' singular value decomposition (SVD) of the block-Hankel matrix H in order to
#' specify the hidden state dimension K (for further details see [1]).
#'    
#' @references 1. A. Rau, F. Jaffrezic, J.-L. Foulley, R. W. Doerge (2010). An empirical 
#' Bayesian method for estimating biological networks from temporal microarray
#' data. Statistical Applications in Genetics and Molecular Biology, vol. 9, 
#' iss. 1, article 9.     
#'    
#' @param data_omics OmicsData object.
#' @param consensusGraphs result from static analysis: consensus graph generated 
#' by staticConsensusNet function.
#' @param laghankel integer specifying the maximum relevant time lag to be used 
#' in constructing the block-Hankel matrix.
#' @param cutoffhankel cutoff to determine desired percent of total variance 
#' explained; default = 0.9 as in [1].
#' @param conv.1 value of convergence criterion 1; default value is 0.15 
#' (for further details see [1]).
#' @param conv.2 value of convergence criterion 2; default value is 0.05 
#' (for further details see [1]).
#' @param conv.3 value of convergence criterion 3; default value is 0.05 
#' (for further details see [1]).
#' @param verbose boolean value, verbose output TRUE or FALSE
#' @param max.iter maximum overall iterations; default value is 100 
#' (for further details see [1]).
#' @param max.subiter maximum iterations for hyperparameter updates; 
#' default value is 200 (for further details see [1]).
#' @return list of 2 elements: 
#' 1) output parameters of dynamic network inference with ebdbNet package
#' 2) splines data generated.
#' @keywords manip
#' @export
#' @examples
#' #please run with whole database files (prepared according to vignette)
#' data(OmicsExampleData)
#' data_omics = readOmics(tp_prots = c(0.25, 1, 4, 8, 13, 18, 24), 
#' tp_genes = c(1, 4, 8, 13, 18, 24), OmicsExampleData,
#' PWdatabase = c("biocarta", "kegg", "nci", "reactome"), 
#' TFtargetdatabase = c("chea", "pazar"))
#' \dontrun{
#' data_omics = readTFdata(data_omics)
#' data_omics_plus = readPWdata(data_omics,  
#' loadgenelists = FALSE)
#' data_omics = identifyPWs(data_omics_plus)
#' data_omics = identifyTFs(data_omics)
#' data_omics = enrichPWs(data_omics)
#' data_omics = identifyRsofTFs(data_omics, only_enriched = FALSE, 
#' noTFs_inPW = 1, order_neighbors = 10)
#' data_omics = identifyPWTFTGs(data_omics, only_enriched = FALSE)
#' statConsNet = staticConsensusNet(data_omics)
#' dynamicConsensusNet(data_omics, statConsNet)
#' }
dynamicConsensusNet <- function(data_omics, consensusGraphs, laghankel = 3, 
                                cutoffhankel = 0.9, conv.1 = 0.15, 
                                conv.2 = 0.05, 
                                conv.3 = 0.05, verbose = TRUE, max.iter = 100, 
                                max.subiter = 200){
    
    requireNamespace("ebdbNet", quietly = TRUE)
    requireNamespace("longitudinal", quietly = TRUE)
    as.longitudinal = dataFormat = hankel = ebdbn = NULL
    
    if(class(data_omics) != "OmicsData")
    {stop("Parameter 'data_omics' is not an OmicsData object.")}
    
    if(TRUE %in% !(names(consensusGraphs) %in% 
                       as.character(data_omics[[1]][[1]][[1]][[1]]) &
                       names(consensusGraphs) %in% 
                       as.character(data_omics[[1]][[1]][[1]][[2]])) ) 
    {stop("ConsensusGraphs do not match OmicsData object.")}
    
    prot_nodes = vector()
    gene_nodes = vector()
    for(j in 1: length(consensusGraphs))
    {   prot_nodes = c(prot_nodes, 
                       V(consensusGraphs[[j]])$name[which(V(consensusGraphs[[j]])$color == "red" | 
                                                              V(consensusGraphs[[j]])$color == "yellow" |
                                                              V(consensusGraphs[[j]])$color == "lightblue")])
        gene_nodes = c(gene_nodes, 
                       V(consensusGraphs[[j]])$name[which(V(consensusGraphs[[j]])$color == "green")])
    }
    spl_prot = getFCsplines(data_omics, unique(prot_nodes), "proteins")
    spl_genes = getFCsplines(data_omics, unique(gene_nodes), "genes")
    
    mat_splines_prot = predictFCvals(data_omics, nopredpoints = 50, spl_prot,
                                     "Protein splines")
    mat_splines_genes = predictFCvals(data_omics, nopredpoints = 50, spl_genes,
                                      "Gene splines")
    timevals = mat_splines_prot[[2]]
    rownames(mat_splines_prot[[1]]) = paste(rownames(mat_splines_prot[[1]]),
                                            "_p", sep = "")
    rownames(mat_splines_genes[[1]]) = paste(rownames(mat_splines_genes[[1]]),
                                             "_g", sep = "")
    
    mat_splines = rbind(mat_splines_prot[[1]], mat_splines_genes[[1]])
    
    ts_data = ts(t(mat_splines), start = 0, end = max(timevals),
                 frequency = 50/max(timevals))
    ts_data = as.longitudinal(ts_data)
    ts_data = dataFormat(ts_data)
    K_hankel <- hankel(ts_data, laghankel, cutoffhankel)$dim
    dynConsensusNet = ebdbn(ts_data, K_hankel, input = "feedback", conv.1,
                            conv.2, conv.3, verbose, max.iter, max.subiter)
    return(list(dynConsensusNet, mat_splines))
}

#' Prediction of continous data points via smoothing splines.
#'
#' @param data_omics OmicsData object.
#' @param nopredpoints integer number; how many timpoints should be predicted?
#' @param splineslist list of protein or gene nodes for which splines were 
#' generated: output of getFCsplines function.
#' @param title character vector specifying name of title.
#' @return list of splines matrix values and calculated times. 
#' 
#' @keywords manip
predictFCvals <- function(data_omics, nopredpoints, splineslist, title) {
    
    uni_timepoints = BiocGenerics::union(data_omics[[1]][[1]][[1]][[1]], 
                           data_omics[[1]][[1]][[1]][[2]])
    timevals = seq(0, max(uni_timepoints), length.out = nopredpoints)
    
    splineslist =  splineslist[which(!is.na(splineslist))]
    splines_mat = matrix(ncol = nopredpoints, nrow = length(splineslist))
    rownames(splines_mat) = names(splineslist)
    colnames(splines_mat) = as.character(round(timevals, digits = 2))
    for(k in 1: length(which(!is.na(splineslist))))
    { splines_mat[k,1:50] = predict(splineslist[k][[1]], timevals)$y}
    
    return(list(splines_mat, timevals))
}

#' Get fold change splines.
#' 
#' Calculate the splines used for the dynamic analysis.
#'  
#' @param data_omics OmicsData object.
#' @param nodes character vector of nodes the fold change splines should be 
#' calculated for.
#' @param nodetype character indicating to calculate splines for "proteins" or 
#' "genes".
#' @return splines values used in dynamic analysis.
#' 
#' @keywords manip
getFCsplines <- function(data_omics, nodes, nodetype) {
    
    if(length(nodes)<1)
    {message("Warning: Node number equals 0, no splines can be calculated.\n")
     return(NA)}
    
    if(nodetype == "proteins")
    {timepoints = data_omics[[1]][[1]][[1]][[1]]
     used_list = 1
    }else if(nodetype == "genes"){
        timepoints = data_omics[[1]][[1]][[1]][[2]]
        used_list = 2
    }
    uni_timepoints = BiocGenerics::union(data_omics[[1]][[1]][[1]][[1]], 
                           data_omics[[1]][[1]][[1]][[2]])
    fc = list()
    for(s in 1: length(nodes))
    {
        fc[[s]] = vector()
        fc[[s]][1] = 0
        for(tp in uni_timepoints)
        {
            if(tp %in% timepoints)
            { ind_current_tp = gsub("tp", "", 
                                    names(data_omics[[1]][[2]][[used_list]]))
              if(nodes[s] %in% 
                     data_omics[[1]][[2]][[used_list]][[which(tp == ind_current_tp)]][,1])
              {fc[[s]][which(tp == uni_timepoints)+1] = 
                   data_omics[[1]][[2]][[used_list]][[which(tp == ind_current_tp)]][which(data_omics[[1]][[2]][[used_list]][[which(tp == ind_current_tp)]][,1] == nodes[s]),2]
              }else{
                  fc[[s]][which(tp == uni_timepoints)+1] = fc[[s]][which(tp == uni_timepoints)]
              }
            }else{
                fc[[s]][which(tp == uni_timepoints)+1] = fc[[s]][which(tp == uni_timepoints)]
            }
        }
    }
    names(fc) = nodes
    spl = list()
    for(k in 1: length(fc))
    {
        if(!all(fc[[k]] == 0))
        {spl[[k]] = smooth.spline(c(0,uni_timepoints), fc[[k]], df =4)
        }else{
            spl[[k]] = NA
        }
    }
    names(spl) = nodes
    return(spl)
}


